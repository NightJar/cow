<?php

namespace SilverStripe\Cow\Steps\Release;

use Exception;
use SilverStripe\Cow\Commands\Command;
use SilverStripe\Cow\Model\Changelog\Changelog;
use SilverStripe\Cow\Model\Changelog\ChangelogLibrary;
use SilverStripe\Cow\Model\Modules\Library;
use SilverStripe\Cow\Model\Modules\Project;
use SilverStripe\Cow\Model\Release\ComposerConstraint;
use SilverStripe\Cow\Model\Release\LibraryRelease;
use SilverStripe\Cow\Model\Release\Version;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

/**
 * Creates a new changelog
 */
class CreateChangelog extends ReleaseStep
{
    /**
     * Below this line, any text will be automatically regenerated
     *
     * @var string
     */
    protected $autogeneratedDelimeter = "<!--- Changes below this line will be automatically regenerated -->";

    public function run(InputInterface $input, OutputInterface $output)
    {
        $this->log($output, "Generating changelog content for all releases in this plan");

        // Generate changelogs for each element in this plan
        $this->recursiveGenerateChangelog($output, $this->getReleasePlan());

        /*
        // Generate changelog content
        $changelog = new Changelog();
        $content = $changelog->getMarkdown($output, Changelog::FORMAT_GROUPED);

        // Now we need to merge this content with the file, or otherwise create it
        $path = $this->getChangelogPath();
        $this->writeChangelog($output, $content, $path);

        // Now commit to git (but don't push!)
        $this->commitChanges($output, $path);

        $this->log($output, "Changelog successfully saved!");
        */
    }

    /**
     * Generate changelogs for this release, and all child nodes
     *
     * @param OutputInterface $output
     * @param LibraryRelease $release
     */
    protected function recursiveGenerateChangelog(OutputInterface $output, LibraryRelease $release) {
        // Don't generate changelogs for non-release upgrades (e.g. bump to existing tag)
        if (!$release->getIsNewRelease()) {
            $this->log(
                $output,
                'No changelog for library <info>' . $release->getLibrary()->getName() . '</info> (upgrade, no release)'
            );
            return;
        }

        // Generate changelog for this library only
        $this->generateChangelog($output, $release);

        // Recurse
        foreach($release->getItems() as $child) {
            $this->recursiveGenerateChangelog($output, $child);
        }
    }

    /**
     * Generate changelog for this node only
     *
     * @param OutputInterface $output
     * @param LibraryRelease $release
     * @throws Exception
     */
    protected function generateChangelog(OutputInterface $output, LibraryRelease $release) {
        // Determine if this library has a changelog configured
        if (!$release->getLibrary()->hasChangelog()) {
            $this->log(
                $output,
                'Library <info>' . $release->getLibrary()->getName() . '</info> has no changelog configured.'
            );
            return;
        }

        // Get from version
        $fromVersion = $release->getPriorVersion();
        if (!$fromVersion) {
            $this->log(
                $output,
                "No prior version for library <info>" . $release->getLibrary()->getName() . '</info>, '
                . "skipping changelog for initial release"
            );
            return;
        }

        $this->log(
            $output,
            "Generating changelog for library <info>" . $release->getLibrary()->getName() . '</info>'
            . ' (<comment>' . $fromVersion->getValue() . '</comment> to '
            . '<info>' . $release->getVersion()->getValue() . '</info>)'
        );

        // Given a from version for this release, determine the "from" version for all child dependencies.
        // This does a deep search through composer dependencies and recursively checks out old versions
        // of composer.json to determine historic version information
        $changelogLibrary = $this->getChangelogLibrary($release, $fromVersion);

        // Generate markedown from plan
        $changelog = new Changelog($changelogLibrary);
        $content = $changelog->getMarkdown($output, $release->getLibrary()->getChangelogFormat());

        echo $content;

        // This needs to be cached somewhere for github-tagging, or written to filesystem

        // Build changelog from all items in $release that has a "from" in $priorRelease
        throw new Exception("Not implemented");
    }

    /**
     * Determine historic release plan from a past composer constraint
     *
     * @param LibraryRelease $newRelease
     * @param Version $historicVersion
     * @return ChangelogLibrary Changelog information for a library
     */
    protected function getChangelogLibrary(LibraryRelease $newRelease, Version $historicVersion) {
        // Build root release node
        $historicRelease = new ChangelogLibrary($newRelease, $historicVersion);

        // Check all dependencies from this past commit
        $pastComposer = null;
        foreach ($newRelease->getItems() as $childNewRelease) {
            // Lazy-load historic composer content as needed
            if (!isset($pastComposer)) {
                $pastComposer = $newRelease->getLibrary()->getHistoryComposerData($historicVersion);
            }

            // Check if this release has a historic tag.
            $childReleaseName = $childNewRelease->getLibrary()->getName();
            if (empty($pastComposer['require'][$childReleaseName])) {
                continue;
            }
            $historicConstraintName = $pastComposer['require'][$childReleaseName];

            // Get oldest existing tag that matches the given constraint as the "from" for changelog purposes.
            $historicConstraint = new ComposerConstraint($historicConstraintName, $historicVersion);
            $childVersions = $historicConstraint->filterVersions($childNewRelease->getLibrary()->getTags());
            $childVersions = Version::sort($childVersions, Version::ASC);
            if (empty($childVersions)) {
                throw new \LogicException(
                    "No historic version for library {$childReleaseName} matches constraint {$historicConstraintName}"
                );
            }

            // Check if to == from version
            $childHistoricVersion = reset($childVersions);
            if ($childHistoricVersion->getValue() === $childNewRelease->getVersion()->getValue()) {
                continue;
            }

            // Recursively generate historic tree
            $childChangelog = $this->getChangelogLibrary($childNewRelease, $childHistoricVersion);
            $historicRelease->addItem($childChangelog);
        }

        return $historicRelease;
    }

    /**
     * Get full path to this changelog
     *
     * @return string
     */
    protected function getChangelogPath()
    {
        $folder = $this->getChangelogFolder();

        // Suffix for release
        $suffix = $this->version->getStability();
        if ($suffix) {
            $folder .= DIRECTORY_SEPARATOR . $suffix;
        }

        return $folder . DIRECTORY_SEPARATOR . $this->version->getValue() . ".md";
    }

    /**
     * Find best changelog folder for this repo
     *
     * @return string
     * @throws Exception
     */
    protected function getChangelogFolder()
    {
        $root = $this->getProject()->getDirectory();

        foreach ($this->paths as $path) {
            $directory = realpath($root . DIRECTORY_SEPARATOR . $path);
            if (is_dir($directory)) {
                return $directory;
            }
        }

        throw new Exception("Could not find changelog folder in project {$root}");
    }

    /**
     * Save output to disk
     *
     * @param OutputInterface $output
     * @param string $content
     * @param string $path
     */
    protected function writeChangelog(OutputInterface $output, $content, $path)
    {
        $header = $this->getFileHeader($output, $path);
        file_put_contents($path, $header.$content);
    }

    /**
     * Get header component to put before the changelog content
     *
     * @param OutputInterface $output
     * @param string $path File path to check for existing header
     * @return string
     */
    protected function getFileHeader(OutputInterface $output, $path)
    {
        // Generate new header if no file exists
        if (!file_exists($path)) {
            $this->log($output, "Writing changelog to <info>$path</info>");
            return "# " . $this->version->getValue() . "\n\n" . $this->autogeneratedDelimeter;
        }

        // Given an existing file, attempt to regenerate autogenerated component
        $this->log($output, "<info>$path</info> already exists; Merging changes");
        $content = file_get_contents($path);
        $position = stripos($content, $this->autogeneratedDelimeter);
        if ($position === false) {
            $this->log(
                $output,
                "Warning: autogeneration delimiter could not be found in this file. Content will be appended instead",
                "error"
            );
        } else {
            $content = substr($content, 0, $position);
        }
        return $content . $this->autogeneratedDelimeter;
    }

    public function getStepName()
    {
        return 'changelog';
    }

    /**
     * Commit changes to git
     *
     * @param OutputInterface $output
     * @param string $path
     * @throws Exception
     */
    public function commitChanges(OutputInterface $output, $path)
    {
        $this->log($output, 'Committing changes to git');

        // Get framework to commit to
        $framework = $this->getProject()->getModule('framework');
        if (!$framework) {
            throw new Exception("Could not find module framework in project " . $this->getProject()->getDirectory());
        }
        $repo = $framework->getRepository();

        // Write changes to git
        $repo->run("add", array($path));
        $version = $this->version->getValue();
        $repo->run("commit", array("-m", "Added {$version} changelog"));
    }
}
